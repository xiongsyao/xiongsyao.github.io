<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on Matrix</title>
    <link>https://xiongsyao.github.io/categories/Redis/</link>
    <description>Recent content in Redis on Matrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CH</language>
    <lastBuildDate>Wed, 13 Feb 2019 15:08:22 +0800</lastBuildDate>
    
	<atom:link href="https://xiongsyao.github.io/categories/Redis/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Redis持久化</title>
      <link>https://xiongsyao.github.io/post/2019/02/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Wed, 13 Feb 2019 15:08:22 +0800</pubDate>
      
      <guid>https://xiongsyao.github.io/post/2019/02/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>为什么需要持久化？ redis将数据存储在内存中，一旦redis重启，存储的数据丢失，会导致缓存失效，严重情况下引起缓存雪崩，故需要将存储内容持久化。
持久化的方式？  RDB:通过快照(snapshotting)完成，当符合一定条件时redis会自动将内存中的所有数据生成一份副本并存储在硬盘上。 AOF(append only file): 每次redis执行会更改数据的命令时将命令本身记录下来。 两种持久化方式可以单独使用其中一种，但经常两者结合使用。当同时启用时，Redis通过AOF恢复数据。  RDB的原理？ Redis默认的会将快照文件存储在当前进程的工作目录中的dump.rdb文件中，可以通过配置dir和dbfilename两个参数指定存储路径和文件名。执行过程如下： 1. Redis使用fork函数复制一份当前进程(父进程)和副本(子进程)； 2. 父进程继续处理客户端请求，子进程开始将内存中数据写入硬盘中的临时文件； 3. 当子进程写入完所有数据后会用该临时文件替换旧的RDB文件。
在执行fork使用写时复制(copy-on-write)策略，当fork函数发生的一刻父子进程共享内存，当父进程要更改其中某片内存时，操作系统会将该片数据复制一份(并不是所有内存数据)以保证子进程的数据不受影响。所以RDB文件存储是执行fork那一刻的内存数据。
一旦Redis异常退出，会丢失最后一次快照以后更改的所有数据。
触发RDB的时机？  根据配置规则进行自动快照
Redis允许用户自定义快照条件，当符合快照条件时，会自动执行快照操作。条件由用户在配置文件中定义，由两个参数构成: 时间窗口M和改动的键个数N。每当时间M内被改动的键个数大于N时，即会触发快照。可以配置多个条件，之间的关系是“或”。例如: save 900 3 save 300 1 save 60 10000 则当900秒内有3个键改变或300秒内有一个键被改变或60秒内有10000个键被改变，都会触发快照。
 用户执行SAVE或BGSAVE命令
当执行SAVE命令时，Redis会同步地进行快照，快照过程中会阻塞所有来自客户端的请求，可能会导致Redis长时间不响应，应当避免在生产环境中使用。
BGSAVE命令在后台异步的进行快照，服务器依旧可以响应客户端请求。执行BGSAVE后Redis会立即返回OK表示开始快照。可以通过LASTSAVE命令获取最近一次成功执行快照的时间，以确定是否执行成功。
 执行FLUSHALL命令
当执行FLUSHALL命令时，只要自动快照条件(不论条件是什么)不为空，就会执行一次快照操作, 当不存在快照条件时，则不会触发。
 执行复制(replication)时
当设置了主从模式时，Redis会在复制初始化时进行自动快照。
  AOF持久化怎么开启？如何去除冗余命令？ 默认情况下Redis没有开启AOF方式的持久化，可以通过appendonly参数启用: appendonly yes。开启AOF持久化后每执行一条会更改Redis中数据的命令，就会将该命令写入硬盘的AOF文件，AOF文件的保存位置与RDB文件的位置一致，通过dir和appendfilename设置目录和文件名，默认为appendonly.conf。
AOF文件以纯文本的形式记录Redis命令(这里指RESP协议化的命令)。随着执行命令越来越多，文件也会越来越大，中间会记录冗余的命令(例如对同一个键的多次SET操作)。通过在配置文件中更改设置，可以做到满足条件时，Redis自动重写AOF文件:
auto-aof-rewrite-percentage 100 # 当前AOF文件大小超过上一次重写时的AOF文件大小百分之多少时触发重写 auto-aof-rewrite-min-size 64mb # 当AOF文件小于这个值时不再触发重写  也可以执行BGREWRITEAOF命令手动的异步执行AOF重写。
AOF持久化是否必要？会有性能问题吗？如何避免性能问题？ RDB方式实现持久化时，一旦Redis异常退出，会丢失最后一次快照以后更改的所有数据。若数据比较重要，就需要配合AOF方式进行持久化。
AOF会将redis执行的每一条写命令追加到硬盘文件中，这一过程显然会降低redis的性能，但是大部分情况下这个情况是可以接受的，可以使用较快的硬盘提高AOF的性能。
AOF方式持久化的数据一定不会丢失吗？ 虽然每次执行更改数据的操作时Redis都会将命令记录在AOF文件中，但事实上，由于操作系统的缓存机制，数据并没有真正的写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒执行一次同步操作，将硬盘缓存中的内容真正写入到硬盘中，在这30秒内，如果系统异常退出就会导致硬盘缓存中的数据丢失。</description>
    </item>
    
    <item>
      <title>解读redis协议</title>
      <link>https://xiongsyao.github.io/post/2019/01/02/%E8%A7%A3%E8%AF%BBredis%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Wed, 02 Jan 2019 17:20:16 +0800</pubDate>
      
      <guid>https://xiongsyao.github.io/post/2019/01/02/%E8%A7%A3%E8%AF%BBredis%E5%8D%8F%E8%AE%AE/</guid>
      <description>前言 Redis作为我们日常使用的key-value数据库，不光操作简单(例如set get delete等指令)，通信协议也简洁明了。 本篇就会剖析Redis的通信协议，并且实现一个简单的Redis客户端。
协议 Redis服务端与客户端使用的基于TCP的文本协议(敲黑板，这里并没有使用效率更高的二进制协议)，称之为RESP(Redis Serialization Protocol)。区别于同样是文本协议的HTTP协议，RESP尤为简洁，其基础规则很容易理解。
请求信息 假如我们执行set test ok这样的命令，可以视为准备了一个[&amp;quot;set&amp;quot;, &amp;quot;test&amp;quot;, &amp;quot;ok&amp;quot;]这样的数组，随即将其序列化为字符串，序列化规则如下:
 首先以每一个指令以*开头指明数组长度 以$开头指明下个元素的字符长度 每一个元素以间隔符号\r\n(CRLF)隔开  按这个规则,set test ok则为:
*3\r\n $3\r\n set\r\n $4\r\n test\r\n $2\r\n ok\r\n  以python为例:
import redis r = redis.Redis() r.set(&#39;hello&#39;, &#39;world&#39;)  那么将发送的指令为*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n，收到的响应为+OK\r\n。
响应信息 RESP协议中，不同类型的响应信息，会以不同的字符开头，比如上例中，+OK\r\n就以+开头。
 简单字符串(Simple Strings)响应会以&amp;rdquo;+&amp;ldquo;开头
 +OK\r\n
 错误(Errors)响应会以&amp;rdquo;-&amp;ldquo;开头
 -ERR unkown command &amp;lsquo;ST&amp;rsquo;\r\n
 数字(Integer)响应会以&amp;rdquo;:&amp;ldquo;开头
 :2\r\n
 大字符串(Bulk Strings)会以&amp;rdquo;$&amp;ldquo;开头，并且随之标出字符串字节数
 $13\r\nHello, World!\r\n
 数组类型(Arrays)类似与请求信息的序列化一致（在HGETALLLRANGEMGET命令中会返回)。
  实例 接下来，我们将用go实现一个简单的redis客户端</description>
    </item>
    
  </channel>
</rss>