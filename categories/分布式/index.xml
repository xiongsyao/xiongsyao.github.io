<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式 on Matrix</title>
    <link>https://xiongsyao.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on Matrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CH</language>
    <lastBuildDate>Wed, 27 Feb 2019 15:00:16 +0800</lastBuildDate>
    
	<atom:link href="https://xiongsyao.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>漫谈分布式锁（三）</title>
      <link>https://xiongsyao.github.io/post/2019/02/27/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%89/</link>
      <pubDate>Wed, 27 Feb 2019 15:00:16 +0800</pubDate>
      
      <guid>https://xiongsyao.github.io/post/2019/02/27/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%89/</guid>
      <description>在上一节中，我们利用Redis实现了分布式互斥锁。虽然相较于基于MySQL的解决方案，它已经解决了很多问题，但是仍然有一些不足（不讨论RedLock解放方案）:
 非高可用，一旦Redis服务挂了，极大影响锁的使用。 没有正确估计锁的过期时间pexpire时，很容易造成，业务逻辑处理时间过长，导致频繁产生解锁失败的错误。若设置过长，会影响获取锁的效率。 持有锁的工作线程出错后，必须等待过期时间结束才能释放锁，并不能立即释放。 阻塞锁的实现方式需要通过while循环实现。  在这一节中，我们通过Zookeeper实现分布式互斥锁。
优势 Zookeeper作为一个分布式应用协调程序，常用来做配置管理、服务发现。它的所有写入动作会在Leader节点持久化，并在集群过半数节点写入成功才会返回，它也能够支持节点的崩溃恢复以及客户端的最终一致性视图。得益于这一特性，基于zk实现的分布式锁，只要节点数大于等于三，就是天然高可用的。
zk的这些特性可以用于分布式锁中:
 永久节点: 节点创建之后，不会因为会话失效而消失，需要主动删除。用来作为锁的根节点。
 临时节点: 临时节点将在当前客户端与服务端建立的session到期时自动删除，这个特性可以保障客户端创建的分布式锁节点在客户端宕机或者网络通讯中断一段时间后自动释放该临时节点，从而避免分布式锁由于客户端或网络原因导致的死锁问题。
 顺序节点: 顺序节点将自动在客户端指定的节点名后面添加一个单调递增序号来确保多个客户端同时创建相同的节点名时能够创建成功，并且保障越早创建的节点的序号越小。利用该特性可以实现锁的互斥性和公平性，即同一时刻只有一个客户端能够成功获取到锁（序号最小的一个获取到锁），获取锁失败的节点可以按照创建顺序进行锁等待。
 监视器（watcher）: 当创建一个节点时，当前客户端可以注册一个该节点的监视器，当节点状态改变（删除或更新）时，zk将会向此客户端发送一条通知。应用watcher机制，正在等待锁的客户端就可以及时得知锁被释放，进行抢占锁的动作。
  实现思路  创建锁目录lock。 希望获得锁的客户端在lock目录下创建临时顺序节点。 获取锁目录下所有子节点，拿到最小子节点，并判断最小子节点是不是与自身的节点相同，若是，则获取锁。否则，监听比自己次小的节点(这里不是监听最小节点，为了防止“羊群效应”)，当比自己次小的节点被删除时，重复此步骤知道获取锁。 客户端处理完业务，删除自己的节点，释放锁。  具体实现 因为Zookeeper常用于作为分布式锁，所有很多语言的Zookeeper包都为我们内置了lock。以python为例:
import time from kazoo.client import KazooClient zk = KazooClient(&amp;quot;127.0.0.1:2181&amp;quot;) zk.start() lock = zk.Lock(&amp;quot;/lockpath&amp;quot;, &amp;quot;my-identifier&amp;quot;) with lock: # blocks waiting for lock acquisition # do something with the lock time.sleep(5)  kazoo还为我们提供了除互斥锁外更多种类的锁，可以看官方文档了解下。</description>
    </item>
    
    <item>
      <title>漫谈分布式锁（二）</title>
      <link>https://xiongsyao.github.io/post/2019/02/25/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BA%8C/</link>
      <pubDate>Mon, 25 Feb 2019 17:20:58 +0800</pubDate>
      
      <guid>https://xiongsyao.github.io/post/2019/02/25/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BA%8C/</guid>
      <description>回顾 在上一节中，我们利用MySQL实现了一个简单的分布式锁，但是，这样实现的分布式锁存在以下缺点：
 IO时间过长，获取锁与释放锁的过程远不如从内存中获取快。 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁。 只能是阻塞锁或非阻塞锁。 不可重入，同一线程在没有释放锁之前无法再获取到锁。  这一节，我们尝试用Redis实现，看看是否能解决上述问题。
单机实现 类比MySQL的方案1，我们可以快速给出一个粗糙的思路：
在Redis中只需要在加锁时设置(setnx, set if not exists)一个唯一的key，并且值也为特殊生成的uuid，更具setnx的特性，假如这个key已存在，则加锁失败，不存在，则枷锁成功。同时，针对MySQL加锁的问题2，我们可以利用expire为这个key主动设置失效时间。释放锁时，通过比较GET key的值与线程的锁的uuid是否一致，如果相等，则说明是同一把锁，通过delete就可以删除这把锁，不一致，就表示可能业务逻辑超时或者网络延迟，导致锁已经失效，此时不做任何处理，防止影响其他线程正常使用锁。
假如我们需要占用一把名为Rlocker的锁，用Redis命令表示出来为:
&amp;gt; SETNX Rlocker uuid # 加锁：SETNX仅当key不存在时，才会设置成功，返回1， 否则返回0 (integer) 1 &amp;gt; EXPIRE Rlocker 1 # 设置失效时间: EXPIRE设置当前key失效时间，单位为秒，PEXPIRE单位为毫秒 (integer) 1 &amp;gt; DEL Rlocker # 释放锁 (integer) 0  实现一个简单的ReMutex类:
import uuid import redis r = redis.Redis(host=&amp;quot;localhost&amp;quot;, port=6379, db=0) class ReMutex: def __init__(self, name, pexpire=500): self.name = name self._key = &amp;quot;re:locker:{}&amp;quot;.format(name) self._uuid = str(uuid.uuid1()) # 这里最好替换成其他的id生成算法 self.</description>
    </item>
    
    <item>
      <title>漫谈分布式锁（一）</title>
      <link>https://xiongsyao.github.io/post/2019/02/21/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%80/</link>
      <pubDate>Thu, 21 Feb 2019 20:35:47 +0800</pubDate>
      
      <guid>https://xiongsyao.github.io/post/2019/02/21/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%80/</guid>
      <description>为什么需要分布式锁 之前介绍过Go中的锁，在多个协程(线程)抢占同一资源时，为了防止相互干扰，保持一致性，需要运用到锁机制，得益于线程的共享内存，大部分语言都在标准库中为我们提供了锁。但是在跨进程、跨主机程序协作中，就需要我们自己去实现，我们需要自己为所有进程提供一个&amp;rdquo;共享内存&amp;rdquo;，并在其中实现自己的“锁”。
分布式锁需要实现的功能  获取锁与释放锁的性能要好，足够快； 获取锁必须是原子性的，否则会导致多个进程都持有锁； 具备锁失效机制，当获取到锁的进程(线程)，因为网络问题或者自身异常退出，无法提交释放锁的请求时，锁应当自己清除掉； 同一线程可以多次获取同一把锁，即可重入性； 具备非阻塞锁和阻塞锁特性。当没有获取到锁时，非阻塞锁直接返回锁失败，阻塞锁会使线程继续等待获取锁。  常见的分布式锁实现方案  基于数据库实现; 基于缓存(Redis)实现； 基于Zookeeper实现; 基于etcd实现。  本篇先介绍基于数据库实现的分布式锁。
基于数据库的分布式锁 利用唯一索引 该实现方式完全依靠数据库唯一索引来实现，当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除这条记录。
创建表:
CREATE TABLE `dbmutex` ( `name` varchar(64) NOT NULL, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`name`), UNIQUE KEY `uidx_name` (`name`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8  依赖于这张表，实现一个简单的DBMutex类
import MySQLdb class Driver: def __init__(self, address=&amp;quot;localhost&amp;quot;, username=&amp;quot;root&amp;quot;, password=&amp;quot;123456&amp;quot;, dbname=&amp;quot;LOCKER&amp;quot;): self.db = MySQLdb.connect(address, username, password, dbname, charset=&#39;utf8&#39;) self.</description>
    </item>
    
  </channel>
</rss>