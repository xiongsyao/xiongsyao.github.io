<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式 on Matrix</title>
    <link>https://xiongsyao.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on Matrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CH</language>
    <lastBuildDate>Mon, 25 Feb 2019 17:20:58 +0800</lastBuildDate>
    
	<atom:link href="https://xiongsyao.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>漫谈分布式锁（二）</title>
      <link>https://xiongsyao.github.io/post/2019/02/25/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BA%8C/</link>
      <pubDate>Mon, 25 Feb 2019 17:20:58 +0800</pubDate>
      
      <guid>https://xiongsyao.github.io/post/2019/02/25/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BA%8C/</guid>
      <description>回顾 在上一节中，我们利用MySQL实现了一个简单的分布式锁，但是，这样实现的分布式锁存在以下缺点：
 IO时间过长，获取锁与释放锁的过程远不如从内存中获取快。 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁。 只能是阻塞锁或非阻塞锁。 不可重入，同一线程在没有释放锁之前无法再获取到锁。  这一节，我们尝试用Redis实现，看看是否能解决上述问题。
单机实现 类比MySQL的方案1，我们可以快速给出一个粗糙的思路：
在Redis中只需要在加锁时设置(setnx, set if not exists)一个唯一的key，并且值也为特殊生成的uuid，更具setnx的特性，假如这个key已存在，则加锁失败，不存在，则枷锁成功。同时，针对MySQL加锁的问题2，我们可以利用expire为这个key主动设置失效时间。释放锁时，通过比较GET key的值与线程的锁的uuid是否一致，如果相等，则说明是同一把锁，通过delete就可以删除这把锁，不一致，就表示可能业务逻辑超时或者网络延迟，导致锁已经失效，此时不做任何处理，防止影响其他线程正常使用锁。
假如我们需要占用一把名为Rlocker的锁，用Redis命令表示出来为:
&amp;gt; SETNX Rlocker uuid # 加锁：SETNX仅当key不存在时，才会设置成功，返回1， 否则返回0 (integer) 1 &amp;gt; EXPIRE Rlocker 1 # 设置失效时间: EXPIRE设置当前key失效时间，单位为秒，PEXPIRE单位为毫秒 (integer) 1 &amp;gt; DEL Rlocker # 释放锁 (integer) 0  实现一个简单的ReMutex类:
import uuid import redis r = redis.Redis(host=&amp;quot;localhost&amp;quot;, port=6379, db=0) class ReMutex: def __init__(self, name, pexpire=500): self.name = name self._key = &amp;quot;re:locker:{}&amp;quot;.format(name) self._uuid = str(uuid.uuid1()) # 这里最好替换成其他的id生成算法 self.</description>
    </item>
    
    <item>
      <title>漫谈分布式锁（一）</title>
      <link>https://xiongsyao.github.io/post/2019/02/21/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%80/</link>
      <pubDate>Thu, 21 Feb 2019 20:35:47 +0800</pubDate>
      
      <guid>https://xiongsyao.github.io/post/2019/02/21/%E6%BC%AB%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%80/</guid>
      <description>为什么需要分布式锁 之前介绍过Go中的锁，在多个协程(线程)抢占同一资源时，为了防止相互干扰，保持一致性，需要运用到锁机制，得益于线程的共享内存，大部分语言都在标准库中为我们提供了锁。但是在跨进程、跨主机程序协作中，就需要我们自己去实现，我们需要自己为所有进程提供一个&amp;rdquo;共享内存&amp;rdquo;，并在其中实现自己的“锁”。
分布式锁需要实现的功能  获取锁与释放锁的性能要好，足够快； 获取锁必须是原子性的，否则会导致多个进程都持有锁； 具备锁失效机制，当获取到锁的进程(线程)，因为网络问题或者自身异常退出，无法提交释放锁的请求时，锁应当自己清除掉； 同一线程可以多次获取同一把锁，即可重入性； 具备非阻塞锁和阻塞锁特性。当没有获取到锁时，非阻塞锁直接返回锁失败，阻塞锁会使线程继续等待获取锁。  常见的分布式锁实现方案  基于数据库实现; 基于缓存(Redis)实现； 基于Zookeeper实现; 基于etcd实现。  本篇先介绍基于数据库实现的分布式锁。
基于数据库的分布式锁 利用唯一索引 该实现方式完全依靠数据库唯一索引来实现，当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除这条记录。
创建表:
CREATE TABLE `dbmutex` ( `name` varchar(64) NOT NULL, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`name`), UNIQUE KEY `uidx_name` (`name`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8  依赖于这张表，实现一个简单的DBMutex类
import MySQLdb class Driver: def __init__(self, address=&amp;quot;localhost&amp;quot;, username=&amp;quot;root&amp;quot;, password=&amp;quot;123456&amp;quot;, dbname=&amp;quot;LOCKER&amp;quot;): self.db = MySQLdb.connect(address, username, password, dbname, charset=&#39;utf8&#39;) self.</description>
    </item>
    
  </channel>
</rss>